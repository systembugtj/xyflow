/** @jsxImportSource @wsxjs/wsx-core */
/**
 * NodeResizeControl 组件
 * 完全按照 React 端设计实现
 */
import { LightComponent, autoRegister, state } from '@wsxjs/wsx-core';
import {
  XYResizer,
  ResizeControlVariant,
  type XYResizerInstance,
  type ControlPosition,
  type ResizeControlDirection,
} from '@xyflow/system';
import { classcat } from '../../utils/web-components';
import styles from '../../styles/base.css?inline';

const defaultPositions: Record<ResizeControlVariant, ControlPosition> = {
  [ResizeControlVariant.Line]: 'right',
  [ResizeControlVariant.Handle]: 'bottom-right',
};

@autoRegister({ tagName: 'xyflow-node-resize-control' })
export default class NodeResizeControl extends LightComponent {
  @state private nodeId: string = '';
  @state private position: ControlPosition = {};
  @state private variant: ResizeControlVariant = ResizeControlVariant.Handle;
  @state private color: string = '';
  @state private minWidth = 10;
  @state private minHeight = 10;
  @state private maxWidth = Number.MAX_VALUE;
  @state private maxHeight = Number.MAX_VALUE;
  @state private keepAspectRatio = false;
  @state private autoScale = true;
  @state private resizeDirection: ResizeControlDirection = {};

  private resizeControlRef: HTMLDivElement | null = null;
  private resizer: XYResizerInstance | null = null;

  constructor() {
    super({
      styles,
      styleName: 'xyflow-node-resize-control',
    });
  }

  static get observedAttributes() {
    return [
      'node-id',
      'position',
      'variant',
      'color',
      'min-width',
      'min-height',
      'max-width',
      'max-height',
      'keep-aspect-ratio',
      'auto-scale',
      'resize-direction',
      'class',
      'style',
    ];
  }

  protected onAttributeChanged(name: string, _oldValue: string, newValue: string) {
    switch (name) {
      case 'node-id':
        this.nodeId = newValue || undefined;
        break;
      case 'position':
        this.position = (newValue as ControlPosition) || undefined;
        break;
      case 'variant':
        this.variant = (newValue as ResizeControlVariant) || ResizeControlVariant.Handle;
        break;
      case 'color':
        this.color = newValue || undefined;
        break;
      case 'min-width':
        this.minWidth = parseFloat(newValue) || 10;
        break;
      case 'min-height':
        this.minHeight = parseFloat(newValue) || 10;
        break;
      case 'max-width':
        this.maxWidth = parseFloat(newValue) || Number.MAX_VALUE;
        break;
      case 'max-height':
        this.maxHeight = parseFloat(newValue) || Number.MAX_VALUE;
        break;
      case 'keep-aspect-ratio':
        this.keepAspectRatio = newValue !== 'false';
        break;
      case 'auto-scale':
        this.autoScale = newValue !== 'false';
        break;
      case 'resize-direction':
        this.resizeDirection = (newValue as ResizeControlDirection) || undefined;
        break;
    }
    this.updateResizer();
  }

  connectedCallback() {
    super.connectedCallback?.();
    const contextNodeId = this.getAttribute('data-nodeid');
    this.nodeId = this.nodeId || contextNodeId || undefined;
    this.initResizer();
  }

  disconnectedCallback() {
    if (this.resizer) {
      this.resizer.destroy();
      this.resizer = null;
    }
    super.disconnectedCallback?.();
  }

  private initResizer = () => {
    if (!this.resizeControlRef || !this.nodeId) {
      return;
    }

    const flowElement = this.closest('xyflow-flow') as any;
    const flow = flowElement?.flow;
    if (!flow) return;

    this.resizer = XYResizer({
      domNode: this.resizeControlRef,
      nodeId: this.nodeId,
      getStoreItems: () => {
        const flowState = flow.getState?.() || {};
        const viewport = flow.getViewport();
        return {
          nodeLookup: flowState?.nodeLookup || new Map(),
          transform: [viewport.x, viewport.y, viewport.zoom],
          snapGrid: flowState?.snapGrid,
          snapToGrid: flowState?.snapToGrid || false,
          nodeOrigin: flowState?.nodeOrigin || [0, 0],
          paneDomNode: flowState?.domNode || null,
        };
      },
      onChange: (change, childChanges) => {
        const flowState = flow.getState?.() || {};
        const triggerNodeChanges = flowState?.triggerNodeChanges;
        if (triggerNodeChanges) {
          // 构建节点变化
          const changes: any[] = [];
          if (change.x !== undefined && change.y !== undefined) {
            changes.push({
              id: this.nodeId,
              type: 'position',
              position: { x: change.x, y: change.y },
            });
          }
          if (change.width !== undefined && change.height !== undefined) {
            changes.push({
              id: this.nodeId,
              type: 'dimensions',
              resizing: true,
              setAttributes: !this.resizeDirection ? true : this.resizeDirection === 'horizontal' ? 'width' : 'height',
              dimensions: {
                width: change.width,
                height: change.height,
              },
            });
          }
          triggerNodeChanges(changes);
        }
      },
      onEnd: ({ width, height }) => {
        const state = flow.getState?.() || {};
        const triggerNodeChanges = state.triggerNodeChanges;
        if (triggerNodeChanges) {
          triggerNodeChanges([
            {
              id: this.nodeId,
              type: 'dimensions',
              resizing: false,
              dimensions: { width, height },
            },
          ]);
        }
      },
    });

    this.updateResizer();
  };

  private updateResizer = () => {
    if (!this.resizer) return;

    const controlPosition = this.position ?? defaultPositions[this.variant];
    const flowState = (this.closest('xyflow-flow') as any)?.flow?.getState?.() || {};

    this.resizer.update({
      controlPosition,
      boundaries: {
        minWidth: this.minWidth,
        minHeight: this.minHeight,
        maxWidth: this.maxWidth,
        maxHeight: this.maxHeight,
      },
      keepAspectRatio: this.keepAspectRatio,
      resizeDirection: this.resizeDirection,
      onResizeStart: flowState?.onResizeStart,
      onResize: flowState?.onResize,
      onResizeEnd: flowState?.onResizeEnd,
      shouldResize: flowState?.shouldResize,
    });
  };

  render() {
    const controlPosition = this.position ?? defaultPositions[this.variant];
    const positionClassNames = controlPosition.split('-');
    const isHandleControl = this.variant === ResizeControlVariant.Handle;

    // 计算 scale（用于 autoScale）
    const flowElement = this.closest('xyflow-flow') as any;
    const flow = flowElement?.flow;
    const viewport = flow?.getViewport() || { zoom: 1 };
    const scale = isHandleControl && this.autoScale ? Math.max(1 / viewport.zoom, 1) : undefined;

    const style: Record<string, string> = {
      ...(scale ? { scale: String(scale) } : {}),
      ...(this.color && { [isHandleControl ? 'backgroundColor' : 'borderColor']: this.color }),
      ...(this.getAttribute('style') ? JSON.parse(this.getAttribute('style') || '{}') : {}),
    };

    return (
      <div
        ref={(el) => {
          this.resizeControlRef = el;
          if (el && !this.resizer) {
            this.initResizer();
          }
        }}
        class={classcat(
          'xyflow__resize-control',
          'nodrag',
          ...positionClassNames,
          this.variant,
          this.getAttribute('class') || ''
        )}
        style={style}
      >
        <slot />
      </div>
    );
  }
}
